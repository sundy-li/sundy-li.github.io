<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>探索Snowflake auto clustering 设计 - sundy-li的博客</title><meta name=Description content="sundy-li写东西的地方"><meta property="og:title" content="探索Snowflake auto clustering 设计"><meta property="og:description" content="TLDR Snowflake IPO 大火之后，大家都开始慢慢了解到这个完全基于云计算设计的新式数据仓库。 Snowflake 的核心在于基于云端近似无限的计算存储资源，提供了极致弹性且高效的"><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/posts/%E6%8E%A2%E7%B4%A2snowflake-auto-clustering/"><meta property="og:image" content="http://example.org/logs/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-26T15:48:20+08:00"><meta property="article:modified_time" content="2022-03-26T15:48:20+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://example.org/logs/logo.png"><meta name=twitter:title content="探索Snowflake auto clustering 设计"><meta name=twitter:description content="TLDR Snowflake IPO 大火之后，大家都开始慢慢了解到这个完全基于云计算设计的新式数据仓库。 Snowflake 的核心在于基于云端近似无限的计算存储资源，提供了极致弹性且高效的"><meta name=application-name content="sundy-li的博客"><meta name=apple-mobile-web-app-title content="sundy-li的博客"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://example.org/posts/%E6%8E%A2%E7%B4%A2snowflake-auto-clustering/><link rel=prev href=http://example.org/posts/%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E5%9C%A8databend%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/><link rel=stylesheet href=/lib/normalize/normalize.min.055364f5be272caa092b0e6654c165828707f8ab971e2656383a6d6392bc345e.css integrity="sha256-BVNk9b4nLKoJKw5mVMFlgocH+KuXHiZWODptY5K8NF4="><link rel=stylesheet href=/css/style.min.1e2694bed152fa2922dbe909a441838ed693d88b1330f97485bfa8ed78da42df.css integrity="sha256-HiaUvtFS+iki2+kJpEGDjtaT2IsTMPl0hb+o7XjaQt8="><link rel=stylesheet href=/lib/fontawesome-free/all.min.876d023d9d10c97941b80c3b03e2a5b94631ff7a4af9cee5604a6a2d39718d84.css integrity="sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ="><link rel=stylesheet href=/lib/animate/animate.min.3c770e90f98eb21b0c042fafb49755af93306fbaf42e449524f94fae9fc83295.css integrity="sha256-PHcOkPmOshsMBC+vtJdVr5Mwb7r0LkSVJPlPrp/IMpU="><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"探索Snowflake auto clustering 设计","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/example.org\/posts\/%E6%8E%A2%E7%B4%A2snowflake-auto-clustering\/"},"genre":"posts","keywords":"Snowflake, database, Cloud-native","wordcount":3738,"url":"http:\/\/example.org\/posts\/%E6%8E%A2%E7%B4%A2snowflake-auto-clustering\/","datePublished":"2022-03-26T15:48:20+08:00","dateModified":"2022-03-26T15:48:20+08:00","publisher":{"@type":"Organization","name":"sundy-li"},"author":{"@type":"Person","name":"sundy-li"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"light"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"light"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=sundy-li的博客>sundy-li的博客</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于我 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=sundy-li的博客>sundy-li的博客</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title>关于我</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">探索Snowflake auto clustering 设计</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=http://github.com/sundy-li title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>sundy-li</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/database/><i class="far fa-folder fa-fw"></i>database</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-03-26>2022-03-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 3738 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 8 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#tldr>TLDR</a></li><li><a href=#什么是-auto-clustering>什么是 Auto Clustering</a></li></ul><ul><li><a href=#micro-partition-微分区>Micro Partition (微分区)</a></li><li><a href=#clustered-tables>Clustered Tables</a></li><li><a href=#怎样让表达到-well-clustered->怎样让表达到 Well-Clustered ？</a></li><li><a href=#如何衡量-well-clustered->如何衡量 Well-Clustered ？</a></li><li><a href=#auto-clustering-是如何进行的>Auto Clustering 是如何进行的？</a><ul><li><a href=#part-selection-任务>Part-Selection 任务</a></li><li><a href=#part-merge-任务>Part-Merge 任务</a></li></ul></li><li><a href=#其他优化>其他优化</a></li></ul></nav></div></div><div class=content id=content><h2 id=tldr>TLDR</h2><p><code>Snowflake</code> IPO 大火之后，大家都开始慢慢了解到这个完全基于云计算设计的新式数据仓库。 <code>Snowflake</code> 的核心在于基于云端近似无限的计算存储资源，提供了极致弹性且高效的计算引擎 并且搭配 低成本且同样弹性伸缩的存储，大大减少了用户的心智负担和数据的计算存储成本，让用户更加专注于发挥数据对业务的价值。对于传统的数据仓库来说，<code>Snowflake</code> 就像一块降维打击的 二向箔。</p><p>在业务增长的过程中，客户的数据持续增长，从而导致单表变大，对大表的高效分析依赖于一套高性能的查询引擎。<code>Snowflake</code> 有一个非常核心的功能： <code>Auto Clustering</code>, 极大地提升了大表的查询效率。 我们这里主要探索下，<code>Snowflake</code> 的 <code>Auto Clustering</code> 功能是如何设计的。</p><h2 id=什么是-auto-clustering>什么是 Auto Clustering</h2><blockquote><p>注意: 这里的 Clustering 是指分组、聚类 的意思，注意不要理解为分布式、集群等概念。</p></blockquote><p>Snowflake 的 Clustering 功能 和传统数据的 Partition 分区功能类似。但在传统的数据库系统中，大多依赖一些静态的分区规则来实现数据的物理隔离，比如按时间，按用户特征hash等等。在hive等数据仓库中，最常见到的还是按照时间分区，比如按月、按天分区。 当一个带有分区字段相关的查询过来的时候，分区的裁剪可以直接忽略掉不匹配的数据，这样就可以大大减少了数据的读取和计算量，从而提高查询性能。</p><p>静态分区用法非常简单，比如在Hive中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- Create Partition
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=n>PARTITION</span><span class=w> </span><span class=p>(</span><span class=n>dt</span><span class=o>=</span><span class=s1>&#39;2020-03-26&#39;</span><span class=p>,</span><span class=w> </span><span class=n>hour</span><span class=o>=</span><span class=s1>&#39;08&#39;</span><span class=p>)</span><span class=w> </span><span class=k>location</span><span class=w> </span><span class=s1>&#39;/path/table/20200326/08&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- Then load data into the partition
</span></span></span></code></pre></div><p>但它有以下一些缺点：</p><ul><li>开发人员在建表的时候必须知道数据的分布情况和将来面对的查询模式，增加了用户的心智负担。</li><li>静态分区的规则是固定的，但数据却是随时间在变化的，比如业务持续增长过程中，按天分区的表 新的分区会变大，从而导致分区分布不均匀。</li></ul><p>Snowflake 在设计中 完全抛弃了 传统的静态<code>Partition</code> 的概念，而提出了 <code>Auto Clustering</code> 的新设计。简而言之，用户再也不用关心我的表是如何如何分区了，用户只管插入和查询就是了，数据分组，性能优化我会自动做!!!</p><h1 id=how->How ？</h1><h2 id=micro-partition-微分区>Micro Partition (微分区)</h2><p>虽然抛弃了静态分区，但snowflake 里面还是有 <code>Micro-Partition</code> 和 <code>Cluster Key</code> 的概念。</p><ul><li><p><code>Cluster Key</code> 是排序键，可以由多个字段组成，类似ClickHouse 的 <code>Order Key</code>。</p></li><li><p><code>Micro-Partition</code> 是数据的基本组成单元，一个表的数据是由多个 <code>Micro-Partitions</code> 组成的。 我们可以将它理解为一个物理文件，这个物理文件限制在 50MB-500MB 的大小（未压缩），物理文件采用了列式存储，不同的列存储在不同的连续空间内。Snowflake 会存储 <code>Micro-Partition</code> 的信息到元数据服务中，方便查询的时候通过元数据索引进行剪枝，如：</p><ul><li>每个列的区间索引, 最大值最小值等 (ZoneMap index）</li><li>列分布的直方图信息</li><li>其他..</li></ul></li></ul><blockquote><p>注： 鉴于<code>Micro-Partition</code> 的大小可能到500MB, 个人认为 <code>Micro-Partition</code> 的内部按道理应当划分类似Parquet的pages（clickhouse的mrk)，每个page有自己的索引，这样就可以在 <code>Micro-Partition</code>内部提高查询过滤的性能。不过看 Snowflake 目前的设计来说，微分区级别索引是最小粒度了，暂时没有微分区内部pages索引了，具体原因未知，文章末尾会提到个人的一些猜测。</p></blockquote><h2 id=clustered-tables>Clustered Tables</h2><p>数据表建立后，默认数据是自然序，自然序意味着我们没有做任何处理，数据就按照流入的顺序排列，此时表处于 Unclustered 状态。当 表经历了 Clustering后，每个 <code>Micro-Partitions</code> 会按照指定的<code>key</code>进行排序, 可以理解为给表加了一个排序键，此时表处于 Clustered 状态。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/clustered-tables.png data-srcset="/images/clustered-tables.png, /images/clustered-tables.png 1.5x, /images/clustered-tables.png 2x" data-sizes=auto alt=/images/clustered-tables.png title=Cluster-Tables></p><p>上图来自Snowflake文档。</p><p><code>Clustered</code> 的主要目的是让大部分的查询能高效的裁剪数据，避免不需要的IO读取和计算。</p><p>举个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>country</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>t1</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=k>type</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=nb>date</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;11/2&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>在原始的数据排列中（自然序），上面的SQL会扫描到 <em>4个</em> 微分区。而在 <code>Clustered</code> 状态下，数据已经按照 <code>Cluster Key</code> -> <code>(date, type)</code> 进行排序，所以只会扫描到 <em>1个</em> 微分区，其他的微分区都被引擎结合了存储在元数据的索引进行了裁剪过滤。</p><h2 id=怎样让表达到-well-clustered->怎样让表达到 Well-Clustered ？</h2><p>一般来说，大表不会是静态的数据，大多会是时序数据，也就是说说数据不断地实时流入。因此，对整个表级别的数据全排序是非常不现实的，不仅代价较高，实时流入的数据也会影响全排序结果。另外一种方法是只对流入的数据进行排序，这样虽然新数据有比较好的顺序，但随着数据在不断地流入，数据整体的顺序会逐渐趋于混乱。</p><p>结合上面的分析，一个表如果能达到 <code>Well-Clustered</code>（表数据的整体有序度高), 这样查询才能高效。在这个前提下，还需要保证 “新数据能实时高效流入“（确保DML高效），两者之间存在一个平衡点， Snowflake 的做法是 优先保证新数据能实时高效流入，新数据是不需要对数据整体的有序度 “负责”，因为新数据相比历史数据来说量级较小，影响的有序度也较小，它只需保证局部有序就行了（确保新数据查询也能高效）。新数据在后台会异步进行合并，保证 ”表数据的整体有序度高“，也就是说 <em>数据的整体有序是一个渐进的过程，而不是整体绝对有序的</em>。</p><h2 id=如何衡量-well-clustered->如何衡量 Well-Clustered ？</h2><p>Snowflake 引入了几个主要的指标来衡量表的 <code>Well-Clustered</code> 程度：</p><ul><li>width: 在一个Range范围内，有多少个 <code>Micro-Partitions</code> 有重叠</li><li>depth: 在一个数据点中，有多少个 <code>Micro-Partitions</code> 有重叠</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/measuring-clustering.png data-srcset="/images/measuring-clustering.png, /images/measuring-clustering.png 1.5x, /images/measuring-clustering.png 2x" data-sizes=auto alt=/images/measuring-clustering.png title=measuring-clustering></p><p>上面的图从上到下展示了四种 表 Cluster 的状态， 第一种情况是4个 微分区 完全重叠，这种情况是最糟糕的，因为它没有任何区分度，命中了A-Z这个Range的查询会不可避免地扫描四个分区。 随着Depth指标的下降，表中微分区变得逐渐离散， <code>Overlap</code> 的 <code>Width</code> 指标也在下降，表也逐渐变得更加 <code>Well-Clustered</code>。</p><p>当然，在实际的表分布中，微分区的分布要达到最下面那样规整（全局有序）是不现实的，因为所需要的开销太大了。</p><ul><li>levels： 微分区所属的级别</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/cluster-level1.png data-srcset="/images/cluster-level1.png, /images/cluster-level1.png 1.5x, /images/cluster-level1.png 2x" data-sizes=auto alt=/images/cluster-level1.png title=cluster-level1></p><p>为了减少写放大，微分区的合并策略和 <code>LSM-tree</code> 类似，微分区在后台不断地合并后形成新的微分区，每次合并完成后，微分区的 <code>Level</code> 值就会自增（clickhouse也有类似的 Part 合并逻辑），所以 <code>Level</code> 表示的就是微分区经历过的合并次数（用来衡量经历过的合并成本）。新数据流入的微分区 <code>Level</code> 默认是0，<code>Level</code> 越低的微分区中，<code>width</code> 和 <code>depth</code> 指标相对来说会越高，在不断合并的过程中，微分区变得越来越离散，表也变得更加 <code>Well-Clustered</code>。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/cluster-level2.png data-srcset="/images/cluster-level2.png, /images/cluster-level2.png 1.5x, /images/cluster-level2.png 2x" data-sizes=auto alt=/images/cluster-level2.png title=cluster-level2></p><blockquote><p>注意： 微分区只会和同Level的微分区合并， Level 存在最大值，避免写放大太严重。</p></blockquote><h2 id=auto-clustering-是如何进行的>Auto Clustering 是如何进行的？</h2><p><code>Auto Clustering</code> 主要分为两大任务:</p><ul><li>Part-Selection 任务</li><li>Part-Merge 任务</li></ul><p>这块和ClickHouse 的逻辑很类似，但明显的区别是 Snowflake 对云实在太偏爱了，上面所有的任务都可以在云端拉起独立的进程进行，而不需要占用用户的计算资源，并且这两个进程也是微服务化的，可以按需弹性伸缩。</p><h3 id=part-selection-任务>Part-Selection 任务</h3><p>Selection 任务会从某个 <code>Level</code> 中选择出微分区列表集合，选择的策略是启发式的：哪个Range中覆盖的微分区合并后，表的<code>Cluster</code> 状态会更好 来作为选择的目的。</p><p>上面提到的2个指标可以构建一个启发式的算法：</p><ol><li><p>Level 低的优先级的微分区被选择的优先级高，因此新流入的数据能有较高优先级合并到下个Level，Level越高的微分区除非在有充足的资源情况下，不会被合并。</p></li><li><p>Depth 高的微分区被选择的优先级高。</p></li></ol><p><img class=lazyload src=/svg/loading.min.svg data-src=/images/part-selection.png data-srcset="/images/part-selection.png, /images/part-selection.png 1.5x, /images/part-selection.png 2x" data-sizes=auto alt=/images/part-selection.png title=part-selection></p><ul><li>上面的曲线是如何构建的 ？</li></ul><p>横轴对应的就是Key的Range， 纵轴表示 Depth，计算方式大概是：遍历所有的微分区，将微分区的 Range 的 Depth 进行求和，得出对应端点的 Y 值 （这里应该可以用差分数组的数据结构进行优化）</p><ul><li>选择的策略是什么 ？</li></ul><p>上图是选择了两个微分区列表的集合示例，被X轴[x1, x2] 范围有交集的微分区都将被选择 进行合并。</p><p>[X1, X2] 的范围是根据 [x1, x2] 内的平均 Depth 最大决定的，所以 [x1, x2] 比较靠近曲线的波峰。</p><ul><li>为什么不选最高的Depth ？</li></ul><p>可以发现最高点 Depth 虽然最高，但 覆盖的Range 变窄，这样导致选择的微分区数量太小，效率不高，猜测它应该维护了一个最小的Width 阈值 和 最小的Depth 阈值 来决定选择的区间。</p><ul><li>选择的结果是什么 ？</li></ul><p>看有多少个符合条件的波峰，上图是两个符合条件的波峰，这两个波峰互不重合，可以作为选择的结果集合，集合中内包含了微分区的 batches。</p><p>ClickHouse 中也有类似的<a href=https://github.com/ClickHouse/ClickHouse/blob/e9e77b44035d7f749a7833dca31c118afad25449/src/Storages/MergeTree/SimpleMergeSelector.h target=_blank rel="noopener noreffer">选择策略算法</a>，建议读者有时间也可以去了解下。</p><h3 id=part-merge-任务>Part-Merge 任务</h3><p>接收到Selection的列表后，Part-Merge 可以独立地进行微分区的排序和合并，类似一个归并排序的过程。合并后的微分区就是一个全局有序的大微分区了。值得一提的是，合并后的分区如果超过了500MB的阈值上限，就会被分裂成更小的微分区，这和ClickHouse 存储一个大的分区文件 是不同的。</p><p>我猜测可能是：</p><ol><li>Snowflake 和 ClickHouse不一样， 它不再维护微分区内部的稀疏索引， 稀疏索引的最小粒度就是微分区。</li><li>在云端对象存储中，读取整个微分区 比 在微分区内部进行部分Range 虽然IO开销稍大，但差异不会太大， 而且对象存储一般都有对象级别的Cache，所以Snowflake的元数据只存储了微分区粒度的索引。</li></ol><h2 id=其他优化>其他优化</h2><ul><li>锁优化</li></ul><p>Selection 和 Merge 进行不会对原始数据持有锁，也就是说在这两个过程中都不会卡主用户数据的查询和插入。这个优化其实很简单，就是在合并之后，持有对 合并涉及的微分区的锁，然后标记下新的微分区为Active状态，老的微分区为Outdate状态，异步GC删除，一些标志位的更新，涉及锁开销可以忽略不计。</p><ul><li>自动合并服务</li></ul><p>就是上面讲的 Selection 和 Merge 做成两个独立的服务异步运行。 Snowflake 旧版本提供了 手动 Cluster，后面废弃了，我猜测更多是让用户使用便捷，不用去Care Clustering这层操作，因为这些事情后台会自动做了，不当地频繁clustering反而增加了不必要的开销。</p><p>相关配图，参考文章来源：</p><ul><li><a href=https://docs.snowflake.com/en/user-guide/tables-clustering-micropartitions.html target=_blank rel="noopener noreffer">tables-clustering-micropartitions</a></li><li><a href=https://medium.com/snowflake/automatic-clustering-at-snowflake-317e0bb45541 target=_blank rel="noopener noreffer">Automatic Clustering at Snowflake</a></li><li><a href=https://www.linkedin.com/pulse/how-does-automatic-clustering-work-snowflake-minzhen-yang/ target=_blank rel="noopener noreffer">How does automatic clustering work in Snowflake</a></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-03-26</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/snowflake/>Snowflake</a>,&nbsp;<a href=/tags/database/>database</a>,&nbsp;<a href=/tags/cloud-native/>Cloud-native</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E5%9C%A8databend%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/ class=prev rel=prev title=类型体操在databend中的应用><i class="fas fa-angle-left fa-fw"></i>类型体操在databend中的应用</a></div></div><div id=comments><div id=gitalk class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk></a>Gitalk</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=http://github.com/sundy-li target=_blank>sundy-li</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/gitalk/gitalk.min.e1f973627089fc121272c24d146e7c52e316a203fcb362eb2f648d803fc0d327.css integrity="sha256-4flzYnCJ/BIScsJNFG58UuMWogP8s2LrL2SNgD/A0yc="><script type=text/javascript src=/lib/gitalk/gitalk.min.3e68fce688cb68f396c11b65309c267b307f420f01cef269e5e4f3bd769801f0.js integrity="sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.bcff85fb5e00d68802850b393ac7792c997f722f536f38e26638c46dca8e5eb6.js integrity="sha256-vP+F+14A1ogChQs5Osd5LJl/ci9TbzjiZjjEbcqOXrY="></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.615590a2ca2b667afa7c02ef396f5500b62e22795ddbb46448f90494605d09a5.js integrity="sha256-YVWQosorZnr6fALvOW9VALYuInld27RkSPkElGBdCaU="></script><script type=text/javascript src=/lib/lunr/lunr.min.df84a2d58ea594c04a3371b48d020b55ea10284c2ec636e4e331965d7313e29b.js integrity="sha256-34Si1Y6llMBKM3G0jQILVeoQKEwuxjbk4zGWXXMT4ps="></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.0670e9b4fa2d21074238f5a2d88a78ca0cae73bbfa45e0fe15e390551e91c63d.js integrity="sha256-BnDptPotIQdCOPWi2Ip4ygyuc7v6ReD+FeOQVR6Rxj0="></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.7fc53951c80e744b60fcd3fc57ac8c88dd6381cc8dbf956aaee17a062a558f12.js integrity="sha256-f8U5UcgOdEtg/NP8V6yMiN1jgcyNv5VqruF6BipVjxI="></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.fb649fcae62177dfe63e67081ddceb830b5ce1f05a4184e9bbb7d87ac4b8f4e5.js integrity="sha256-+2SfyuYhd9/mPmcIHdzrgwtc4fBaQYTpu7fYesS49OU="></script><script type=text/javascript src=/lib/clipboard/clipboard.min.8a7739925f4c03586479852df840b7061948832a7fda30c8c812d2ea4dd4c4f2.js integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI="></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:100},comment:{gitalk:{admin:["sundy-li"],clientID:"0bbabc78136bab58c4d5",clientSecret:"944414617574f7803ac3b687931e677c371901be",id:"2022-03-26T15:48:20+08:00",owner:"sundy-li",repo:"sundy-li.github.io",title:"探索Snowflake auto clustering 设计"}},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.f51938f3065a40ee841bcb558e4330e31fd26c0ea55343fff8770b88b0319a3c.js integrity="sha256-9Rk48wZaQO6EG8tVjkMw4x/SbA6lU0P/+HcLiLAxmjw="></script></body></html>