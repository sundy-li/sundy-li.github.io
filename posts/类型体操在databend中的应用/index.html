<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title>类型体操在databend中的应用 - sundy-li的博客</title><meta name=Description content="sundy-li写东西的地方"><meta property="og:title" content="类型体操在databend中的应用">
<meta property="og:description" content="春节期间花了前后一个月时间终于重构完了databend的datavalues模块，本文将介绍在新的datavalues系统中是如何使用类型体">
<meta property="og:type" content="article">
<meta property="og:url" content="http://example.org/posts/%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E5%9C%A8databend%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"><meta property="og:image" content="http://example.org/logs/logo.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-02-25T11:21:28+08:00">
<meta property="article:modified_time" content="2022-02-25T11:21:28+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="http://example.org/logs/logo.png">
<meta name=twitter:title content="类型体操在databend中的应用">
<meta name=twitter:description content="春节期间花了前后一个月时间终于重构完了databend的datavalues模块，本文将介绍在新的datavalues系统中是如何使用类型体">
<meta name=application-name content="sundy-li的博客">
<meta name=apple-mobile-web-app-title content="sundy-li的博客"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://example.org/posts/%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E5%9C%A8databend%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/><link rel=prev href=http://example.org/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86/><link rel=stylesheet href=/lib/normalize/normalize.min.055364f5be272caa092b0e6654c165828707f8ab971e2656383a6d6392bc345e.css integrity="sha256-BVNk9b4nLKoJKw5mVMFlgocH+KuXHiZWODptY5K8NF4="><link rel=stylesheet href=/css/style.min.1e2694bed152fa2922dbe909a441838ed693d88b1330f97485bfa8ed78da42df.css integrity="sha256-HiaUvtFS+iki2+kJpEGDjtaT2IsTMPl0hb+o7XjaQt8="><link rel=stylesheet href=/lib/fontawesome-free/all.min.876d023d9d10c97941b80c3b03e2a5b94631ff7a4af9cee5604a6a2d39718d84.css integrity="sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ="><link rel=stylesheet href=/lib/animate/animate.min.3c770e90f98eb21b0c042fafb49755af93306fbaf42e449524f94fae9fc83295.css integrity="sha256-PHcOkPmOshsMBC+vtJdVr5Mwb7r0LkSVJPlPrp/IMpU="><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"类型体操在databend中的应用","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/example.org\/posts\/%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E5%9C%A8databend%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\/"},"genre":"posts","wordcount":4374,"url":"http:\/\/example.org\/posts\/%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E5%9C%A8databend%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\/","datePublished":"2022-02-25T11:21:28+08:00","dateModified":"2022-02-25T11:21:28+08:00","publisher":{"@type":"Organization","name":"sundy-li"},"author":{"@type":"Person","name":"sundy-li"},"description":""}</script></head>
<body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'light'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'light'==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title=sundy-li的博客>sundy-li的博客</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> 文章 </a><a class=menu-item href=/tags/> 标签 </a><a class=menu-item href=/categories/> 分类 </a><a class=menu-item href=/about/> 关于我 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-desktop>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a>
</div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title=sundy-li的博客>sundy-li的博客</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><div class=search-wrapper>
<div class="search mobile" id=search-mobile>
<input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-mobile>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</div>
<a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>
取消
</a>
</div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title>关于我</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>目录</h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single"><h1 class="single-title animated flipInX">类型体操在databend中的应用</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=http://github.com/sundy-li title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>sundy-li</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/database/><i class="far fa-folder fa-fw"></i>database</a>&nbsp;<a href=/categories/databend/><i class="far fa-folder fa-fw"></i>databend</a></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-02-25>2022-02-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 4374 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 9 分钟&nbsp;</div>
</div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#context>Context</a></li>
<li><a href=#尝试>尝试</a></li>
<li><a href=#巧遇type-exercise>巧遇type-exercise</a></li>
<li><a href=#databend-应用类型体操>Databend 应用类型体操</a></li>
<li><a href=#实现>实现</a></li>
<li><a href=#进阶>进阶</a></li>
<li><a href=#过程宏>过程宏</a></li>
<li><a href=#总结>总结：</a></li>
</ul>
</nav></div>
</div><div class=content id=content><blockquote>
<p>春节期间花了前后一个月时间终于重构完了databend的datavalues模块，本文将介绍在新的datavalues系统中是如何使用类型体操的。</p>
</blockquote>
<h2 id=context>Context</h2>
<p>在旧版本的datavalues模块中，我们要编写函数通常需要写很多冗余的代码 加上各种宏结合，代码看起来非常繁琐，比如 <a href=https://github.com/datafuselabs/databend/blob/v0.6.49-nightly/common/functions/src/scalars/udfs/in_basic.rs target=_blank rel="noopener noreffer">in函数的实现</a>：</p>
<p>除了上面的例子，缺点还有：</p>
<ul>
<li>Column是一个enum类型，包含Constant 和 Series(一个ArrayTrait，可以理解为 <code>Arc&lt;dyn Array></code>).</li>
</ul>
<pre tabindex=0><code>pub enum DataColumn {
    // Array of values.
    Array(Series),
    // A Single value.
    Constant(DataValue, usize),
}
</code></pre><p>Constant 列在列式系统中是非常有必要的，它表示列是一个常量值，比如 <code>number + 3</code>, <code>3</code> 就是一个常量列，向量化计算中它会和number列中对应行位置数值进行相加。 常量列可以在runtime计算中节省内存分配回收的开销，在一些特殊的算子中，常量列可以提高不少性能，如 <code>rem by scalar</code>。</p>
<p>为此，我们旧版本的函数计算通常都需要每个地方加入各种 match 来匹配常量列的情况，这样会导致代码的繁琐，而且还会导致代码的可读性差。如果函数的参数非常多，会导致 match 满天飞的情况出现，比如 <a href=https://github.com/datafuselabs/databend/blob/v0.6.49-nightly/common/functions/src/scalars/strings/export_set.rs#L91-L253 target=_blank rel="noopener noreffer">export_set函数</a>。 常量列虽然也可以通过 <code>to_array</code> 方法物化成普通列，物化意味着内存的开销，虽然提高了可读性，但影响了性能。</p>
<ul>
<li>无法通过 scalar 函数来自动形成向量化的函数：</li>
</ul>
<p>比如 comparison 函数，我们需要为 <code>10个基础类型</code> + <code>bool 类型</code> + <code>String 类型</code>的 列运用此函数。 即使我们有一种非常精简的标量函数实现， <code>fn cmp(a: S, b: S) {a.cmp(b)}</code>，也不能自动形成向量化的函数。 根本的原因在于没有将列类型和标量类型在编译期间就进行绑定。</p>
<h2 id=尝试>尝试</h2>
<p>在ClickHouse 或者 Velox等c++ 项目中，这个绑定用一些template技巧就可以很好的解决，但在Rust中，我们需要开启不稳定的GAT特性，既然要绑定的话，那一个雏形大概是：</p>
<ul>
<li>ScalarColumn 的定义</li>
</ul>
<pre tabindex=0><code>pub trait ScalarColumn: Column + Send + Sync + Sized + 'static {
	type OwnedItem: Scalar&lt;ColumnType = Self&gt;;
	fn value_at(&amp;self, index: usize) -&gt; Self::OwnedItem;
}
</code></pre><ul>
<li>Scalar 类型的定义：</li>
</ul>
<pre tabindex=0><code>pub trait Scalar: 'static + Sized + Default + Any
{
    type ColumnType: ScalarColumn&lt;OwnedItem = Self&gt;;
}
</code></pre><p>然后我们为 <code>10个基础类型</code> + <code>bool 类型</code> + <code>String 类型</code> 都加上 <code>Scalar</code>的实现，此处省略一堆macros。</p>
<p>理想很美满，但现实非常悲惨。</p>
<ul>
<li>value_at 返回了对应索引的Scalar值，如果是 <code>10个基础类型</code>， 我们可以返回引用或者值， 如果是 <code>String</code> 类型, 我们返回值意味着每次访问都有一次内存copy，这在列式计算中是开销是非常大的，于是我决定修改 <code>value_at</code>方法，统一返回引用：</li>
</ul>
<pre tabindex=0><code>fn value_at(&amp;self, index: usize) -&gt; &amp;Self::OwnedItem;
</code></pre><p>但 <code>Boolean</code> 类型，我们是无法返回引用的，因为在内存模型中， <code>Boolean</code> 列是一个bitmap实现，没有Owner到boolean值，<code>value_at</code>方法必须返回值。</p>
<p>要解决这个问题，我想到了两个思路：</p>
<ul>
<li>一种是通过unsafe + 锁的方式往这个 BooleanColumn 里面去物化一个 <code>Vec&lt;bool></code>，这样就可以返回引用了, 这个unsafe 略显trick。</li>
<li>第二种是将 <code>BooleanColumn</code> 直接用 <code>Vec&lt;u8></code>存储，但这样和arrow转换内存数据时会有额外的内存copy开销。</li>
</ul>
<p>为此陷入了一些误区，让组里的同学也帮忙想想好的解决思路，但一直没有理想的解决方案。</p>
<h2 id=巧遇type-exercise>巧遇type-exercise</h2>
<p>此事搁置后不久，在github刷到了迟先生开源的 <a href=https://github.com/skyzh/type-exercise-in-rust target=_blank rel="noopener noreffer">类型体操</a>，犹如醍醐灌顶，原来 Rust 还可以这么玩，我怎么没有想到可以绑定 一种引用类型呢？</p>
<p>如果读者没有看过迟先生类型体操项目，强烈推荐去阅读下，同时还有<a href=https://zhuanlan.zhihu.com/p/460977012 target=_blank rel="noopener noreffer">配套知乎专栏</a> 服务。</p>
<p>下面介绍下 类型体操 在databend中是如何运用的。</p>
<h2 id=databend-应用类型体操>Databend 应用类型体操</h2>
<p>和开源的 <code>type-exercise</code> 稍有不同，我们的中心是 <code>Scalar</code> 类型，而不是 <code>Column</code> 类型。</p>
<p><img class=lazyload src=/svg/loading.min.svg data-src=/images/types.jpg data-srcset="/images/types.jpg, /images/types.jpg 1.5x, /images/types.jpg 2x" data-sizes=auto alt=/images/types.jpg title=type-exercise></p>
<p>详见<a href=https://github.com/datafuselabs/databend/blob/dc058c9d22baa9e61763661f77cd10ec62c87c48/common/datavalues/src/scalars target=_blank rel="noopener noreffer">代码</a></p>
<h2 id=实现>实现</h2>
<p>Scalar, ScalarRef， ScalarColumn 的定义和开源版本差不多，这里不再赘述。
这里着重讲讲一些不同之处：</p>
<ul>
<li>
<p>ScalarColumn 无需考虑nullable的存在， nullable 我们在外层会进行统一处理（bitmap取与操作），特殊情况我们可以用 后面讲到的 ScalarViewer 来解决。</p>
</li>
<li>
<p>由于不需要考虑nullable，column生成的迭代器可以利用 <code>slice.iter()</code>,省去了各种bound check的开销，并且无需option封装，省去了分支预测的开销，便于循环中计算的pipeline计算或编译器的自动优化。</p>
</li>
<li>
<p>Scalar 和 ScalarRef 以及 ScalarColumn 有绑定，ScalarRef 和 ScalarColumn 也有绑定， 但是我们需要告诉编译器ScalarColumn中的ScalarRef 和 Scalar中的ScalarRef 是同一个ScalarRef （有点绕），因此我们加了一个额外的 <a href=https://github.com/skyzh/type-exercise-in-rust/commit/56f4daaca1aee38aa894b0067fe8bf7895aff427 target=_blank rel="noopener noreffer">限定</a></p>
</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=w>  </span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Scalar</span>: <span class=o>&#39;</span><span class=nb>static</span> <span class=o>+</span><span class=w> </span><span class=nb>Sized</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Default</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Any</span><span class=w>
</span><span class=w></span><span class=o>+</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=k>for</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w> </span><span class=bp>Self</span>::<span class=n>ColumnType</span>: <span class=nc>ScalarColumn</span><span class=o>&lt;</span><span class=n>RefItem</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span>::<span class=n>RefType</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;&gt;</span><span class=w>
</span><span class=w></span><span class=o>+</span><span class=w> </span><span class=p>{</span><span class=w>
</span></code></pre></div><p>这样一来，我们绑定在ScalarColumn上的类型和绑定在Scalar上的类型就已经产生了级联联动。</p>
<ul>
<li>以Scalar为中心的 <a href=https://github.com/datafuselabs/databend/blob/dc058c9d22baa9e61763661f77cd10ec62c87c48/common/functions/src/scalars/expressions/unary.rs target=_blank rel="noopener noreffer"><code>UnaryExpression</code> 实现</a>:</li>
</ul>
<p>ScalarUnaryFunction 类型：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>ScalarUnaryFunction</span><span class=o>&lt;</span><span class=n>L</span>: <span class=nc>Scalar</span><span class=p>,</span><span class=w> </span><span class=n>O</span>: <span class=nc>Scalar</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>eval</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>l</span>: <span class=nc>L</span>::<span class=n>RefType</span><span class=o>&lt;&#39;</span><span class=nb>_</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>_ctx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>EvalContext</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>O</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=sd>/// Blanket implementation for all binary expression functions
</span><span class=sd></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>L</span>: <span class=nc>Scalar</span><span class=p>,</span><span class=w> </span><span class=n>O</span>: <span class=nc>Scalar</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=w> </span><span class=n>ScalarUnaryFunction</span><span class=o>&lt;</span><span class=n>L</span><span class=p>,</span><span class=w> </span><span class=n>O</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>F</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>F</span>: <span class=nb>Fn</span><span class=p>(</span><span class=n>L</span>::<span class=n>RefType</span><span class=o>&lt;&#39;</span><span class=nb>_</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>EvalContext</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>O</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>eval</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>i1</span>: <span class=nc>L</span>::<span class=n>RefType</span><span class=o>&lt;&#39;</span><span class=nb>_</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>ctx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>EvalContext</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>O</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>(</span><span class=n>i1</span><span class=p>,</span><span class=w> </span><span class=n>ctx</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>ScalarUnaryExpression:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=w>
</span><span class=w></span><span class=sd>/// A common struct to caculate Unary expression scalar op.
</span><span class=sd></span><span class=cp>#[derive(Clone)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>ScalarUnaryExpression</span><span class=o>&lt;</span><span class=n>L</span>: <span class=nc>Scalar</span><span class=p>,</span><span class=w> </span><span class=n>O</span>: <span class=nc>Scalar</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=n>f</span>: <span class=nc>F</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>_phantom</span>: <span class=nc>PhantomData</span><span class=o>&lt;</span><span class=p>(</span><span class=n>L</span><span class=p>,</span><span class=w> </span><span class=n>O</span><span class=p>)</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=p>,</span><span class=w> </span><span class=n>L</span>: <span class=nc>Scalar</span><span class=p>,</span><span class=w> </span><span class=n>O</span>: <span class=nc>Scalar</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=w> </span><span class=n>ScalarUnaryExpression</span><span class=o>&lt;</span><span class=n>L</span><span class=p>,</span><span class=w> </span><span class=n>O</span><span class=p>,</span><span class=w> </span><span class=n>F</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>F</span>: <span class=nc>ScalarUnaryFunction</span><span class=o>&lt;</span><span class=n>L</span><span class=p>,</span><span class=w> </span><span class=n>O</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Create a Unary expression from generic columns  and a lambda function.
</span><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>f</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>f</span><span class=p>,</span><span class=w>
</span><span class=w>            </span><span class=n>_phantom</span>: <span class=nc>PhantomData</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=sd>/// Evaluate the expression with the given array.
</span><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>eval</span><span class=p>(</span><span class=w>
</span><span class=w>        </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>l</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=na>a</span> <span class=nc>ColumnRef</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>ctx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>EvalContext</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;&lt;</span><span class=n>O</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Scalar</span><span class=o>&gt;</span>::<span class=n>ColumnType</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Series</span>::<span class=n>check_get_scalar</span>::<span class=o>&lt;</span><span class=n>L</span><span class=o>&gt;</span><span class=p>(</span><span class=n>l</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>it</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>left</span><span class=p>.</span><span class=n>scalar_iter</span><span class=p>().</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>a</span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>f</span><span class=p>).</span><span class=n>eval</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>ctx</span><span class=p>));</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&lt;</span><span class=n>O</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Scalar</span><span class=o>&gt;</span>::<span class=n>ColumnType</span>::<span class=n>from_owned_iterator</span><span class=p>(</span><span class=n>it</span><span class=p>);</span><span class=w>
</span><span class=w>
</span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>error</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ctx</span><span class=p>.</span><span class=n>error</span><span class=p>.</span><span class=n>take</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>error</span><span class=p>);</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>result</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>上面的 EvalContext 是为了存储计算过程中可能出现的Error， 借助 <code>ScalarUnaryExpression</code>的封装， 我们就可以自动将标量函数的实现转为向量化的实现了，示例：</p>
<p><a href=https://github.com/datafuselabs/databend/blob/fe84f5e40f4ac96306ef71618ade9171d865ea81/common/functions/src/scalars/hashes/hash_base.rs target=_blank rel="noopener noreffer">向量化hash函数</a>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>hash_func</span><span class=o>&lt;</span><span class=n>H</span><span class=p>,</span><span class=w> </span><span class=n>S</span><span class=p>,</span><span class=w> </span><span class=n>O</span><span class=o>&gt;</span><span class=p>(</span><span class=n>l</span>: <span class=nc>S</span>::<span class=n>RefType</span><span class=o>&lt;&#39;</span><span class=nb>_</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>_ctx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>EvalContext</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>O</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w>
</span><span class=w>    </span><span class=n>S</span>: <span class=nc>Scalar</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>O</span>: <span class=nc>Scalar</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>FromPrimitive</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>H</span>: <span class=nc>Hasher</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>Default</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w> </span><span class=o>&lt;</span><span class=n>S</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Scalar</span><span class=o>&gt;</span>::<span class=n>RefType</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span>: <span class=nc>DFHash</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>H</span>::<span class=n>default</span><span class=p>();</span><span class=w>
</span><span class=w>    </span><span class=n>l</span><span class=p>.</span><span class=n>hash</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>h</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=n>O</span>::<span class=n>from_u64</span><span class=p>(</span><span class=n>h</span><span class=p>.</span><span class=n>finish</span><span class=p>()).</span><span class=n>unwrap</span><span class=p>()</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=o>..</span><span class=p>.</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>eval</span><span class=p>(</span><span class=w>
</span><span class=w>        </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>columns</span>: <span class=kp>&amp;</span><span class=nc>common_datavalues</span>::<span class=n>ColumnsWithField</span><span class=p>,</span><span class=w>
</span><span class=w>        </span><span class=n>_input_rows</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>common_datavalues</span>::<span class=n>ColumnRef</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=n>with_match_scalar_types_error</span><span class=o>!</span><span class=p>(</span><span class=n>columns</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>data_type</span><span class=p>().</span><span class=n>data_type_id</span><span class=p>().</span><span class=n>to_physical_type</span><span class=p>(),</span><span class=w> </span><span class=o>|</span><span class=cp>$S</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=kd>let</span><span class=w> </span><span class=n>unary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ScalarUnaryExpression</span>::<span class=o>&lt;</span><span class=cp>$S</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=o>&gt;</span>::<span class=n>new</span><span class=p>(</span><span class=n>hash_func</span>::<span class=o>&lt;</span><span class=n>H</span><span class=p>,</span><span class=w> </span><span class=cp>$S</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=o>&gt;</span><span class=p>);</span><span class=w>
</span><span class=w>		</span><span class=kd>let</span><span class=w> </span><span class=n>col</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>unary</span><span class=p>.</span><span class=n>eval</span><span class=p>(</span><span class=n>columns</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>column</span><span class=p>(),</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>EvalContext</span>::<span class=n>default</span><span class=p>())</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>		</span><span class=nb>Ok</span><span class=p>(</span><span class=n>Arc</span>::<span class=n>new</span><span class=p>(</span><span class=n>col</span><span class=p>))</span><span class=w>
</span><span class=w>	</span><span class=p>})</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span></code></pre></div><p>同理，我们可以实现 以 Scalar 为中心的 <a href=https://github.com/datafuselabs/databend/blob/dc058c9d22baa9e61763661f77cd10ec62c87c48/common/functions/src/scalars/expressions/binary.rs target=_blank rel="noopener noreffer"><code>ScalarBinaryExpression</code></a>, 由于有Constant的存在，实现稍显复杂，因为需要match 四种情况， 不过我们都封装在 <code>ScalarBinaryExpression</code> 内部，函数实现无需重复match，示例：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=cp>#[test]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>test_binary_contains</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=c1>//create two string columns
</span><span class=c1></span><span class=w>    </span><span class=k>struct</span> <span class=nc>Contains</span><span class=w> </span><span class=p>{}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>impl</span><span class=w> </span><span class=n>ScalarBinaryFunction</span><span class=o>&lt;</span><span class=n>Vu8</span><span class=p>,</span><span class=w> </span><span class=n>Vu8</span><span class=p>,</span><span class=w> </span><span class=kt>bool</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Contains</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=k>fn</span> <span class=nf>eval</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>a</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=nb>_</span> <span class=p>[</span><span class=kt>u8</span><span class=p>],</span><span class=w> </span><span class=n>b</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=nb>_</span> <span class=p>[</span><span class=kt>u8</span><span class=p>],</span><span class=w> </span><span class=n>_ctx</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>EvalContext</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span><span class=w>            </span><span class=n>a</span><span class=p>.</span><span class=n>windows</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>len</span><span class=p>()).</span><span class=n>any</span><span class=p>(</span><span class=o>|</span><span class=n>window</span><span class=o>|</span><span class=w> </span><span class=n>window</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w>
</span><span class=w>        </span><span class=p>}</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>binary_expression</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ScalarBinaryExpression</span>::<span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=o>&gt;</span>::<span class=n>new</span><span class=p>(</span><span class=n>Contains</span><span class=w> </span><span class=p>{});</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=mi>10</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>l</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Series</span>::<span class=n>from_data</span><span class=p>(</span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;11&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;22&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;33&#34;</span><span class=p>]);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Series</span>::<span class=n>from_data</span><span class=p>(</span><span class=fm>vec!</span><span class=p>[</span><span class=s>&#34;1&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;2&#34;</span><span class=p>,</span><span class=w> </span><span class=s>&#34;43&#34;</span><span class=p>]);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>expected</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Series</span>::<span class=n>from_data</span><span class=p>(</span><span class=fm>vec!</span><span class=p>[</span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>]);</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>binary_expression</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>eval</span><span class=p>(</span><span class=o>&amp;</span><span class=n>l</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>r</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>EvalContext</span>::<span class=n>default</span><span class=p>())</span><span class=w>
</span><span class=w>            </span><span class=p>.</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>new</span><span class=p>(</span><span class=n>result</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>ColumnRef</span><span class=p>;</span><span class=w>
</span><span class=w>        </span><span class=fm>assert!</span><span class=p>(</span><span class=n>result</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>expected</span><span class=p>);</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><h2 id=进阶>进阶</h2>
<p>虽然有 <code>Unary</code> 和 <code>Binary</code> 两种Expression的封装， 不过有的函数参数众多，单目和双目 表达式都无法覆盖。在这种情况下，我们仍然无法避免对Constant 情况 进行match，这里我们对类型体操进行了扩充，引入了 <code>ScalarViewer</code>的概念，它可以处理 nullable 和 constant 两种特殊的column，并且提供统一的API封装。</p>
<ul>
<li>ScalarViewer 和 Scalar 可以相互绑定，它还可以绑定一个迭代器，同时提供按索引取值和判断null的操作。</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>ScalarViewer</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span>: <span class=nb>Clone</span> <span class=o>+</span><span class=w> </span><span class=nb>Sized</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nc>ScalarItem</span>: <span class=nc>Scalar</span><span class=o>&lt;</span><span class=n>Viewer</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>    </span><span class=k>type</span> <span class=nb>Iterator</span>: <span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>ScalarItem</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Scalar</span><span class=o>&gt;</span>::<span class=n>RefType</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;&gt;</span><span class=w>
</span><span class=w>        </span><span class=o>+</span><span class=w> </span><span class=nb>ExactSizeIterator</span><span class=w>
</span><span class=w>        </span><span class=o>+</span><span class=w> </span><span class=n>TrustedLen</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>try_create</span><span class=p>(</span><span class=n>col</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=na>a</span> <span class=nc>ColumnRef</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=bp>Self</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>value_at</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>index</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>ScalarItem</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>Scalar</span><span class=o>&gt;</span>::<span class=n>RefType</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>valid_at</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>i</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=sd>/// len is implemented in ExactSizeIterator
</span><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>size</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>null_at</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>i</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=o>!</span><span class=bp>self</span><span class=p>.</span><span class=n>valid_at</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>is_empty</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>iter</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=nb>Iterator</span><span class=p>;</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><p>一个 ScalarViewer的实现：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=cp>#[derive(Clone)]</span><span class=w>
</span><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>PrimitiveViewer</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=p>,</span><span class=w> </span><span class=n>T</span>: <span class=nc>PrimitiveType</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>values</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=na>a</span> <span class=p>[</span><span class=n>T</span><span class=p>],</span><span class=w>
</span><span class=w>    </span><span class=c1>// for not nullable column, it&#39;s 0. we only need keep one sign bit to tell `null_at` that it&#39;s not null.
</span><span class=c1></span><span class=w>    </span><span class=c1>// for nullable column, it&#39;s usize::max, validity will be cloned from nullable column.
</span><span class=c1></span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>null_mask</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=c1>// for const column, it&#39;s 0, `value` function will fetch the first value of the column.
</span><span class=c1></span><span class=w>    </span><span class=c1>// for not const column, it&#39;s usize::max, `value` function will fetch the value of the row in the column.
</span><span class=c1></span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>non_const_mask</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>size</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>pos</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>validity</span>: <span class=nc>Bitmap</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span></code></pre></div><p>这里引入了两种 位操作掩码的技巧:</p>
<ul>
<li><code>null_mask</code>, 如果column是非nullable或者constant的，那么 <code>null_mask</code> 就是0，如果是nullable的，那么 <code>null_mask</code> 就是 usize::max</li>
<li><code>non_const_mask</code>: 如果column是constant的，那么 <code>non_const_mask</code> 就是0，如果是非constant的，那么 <code>non_const_mask</code> 就是 usize::max</li>
</ul>
<p>有了两个掩码后，我们可以运用位操作来减少一个if判断的开销:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=cp>#[inline]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>value_at</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>index</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>T</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=bp>self</span><span class=p>.</span><span class=n>values</span><span class=p>[</span><span class=n>index</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>non_const_mask</span><span class=p>]</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=cp>#[inline]</span><span class=w>
</span><span class=w></span><span class=k>fn</span> <span class=nf>valid_at</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>i</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>validity</span><span class=p>.</span><span class=n>get_bit_unchecked</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>null_mask</span><span class=p>)</span><span class=w> </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><ul>
<li>Viewer迭代器：</li>
</ul>
<p>Viewer迭代器的实现就是将 Viewer 的index置为0，然后clone一次</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>fn</span> <span class=nf>iter</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>res</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span><span class=w>	</span><span class=n>res</span><span class=p>.</span><span class=n>pos</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span><span class=w>	</span><span class=n>res</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=c1>// 实现 Iterator trait
</span><span class=c1></span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=bp>Self</span>::<span class=n>Item</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pos</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>size</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=nb>None</span><span class=p>;</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>	</span><span class=kd>let</span><span class=w> </span><span class=n>old</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pos</span><span class=p>;</span><span class=w>
</span><span class=w>	</span><span class=bp>self</span><span class=p>.</span><span class=n>pos</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w>	</span><span class=nb>Some</span><span class=p>(</span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=o>*</span><span class=bp>self</span><span class=p>.</span><span class=n>values</span><span class=p>.</span><span class=n>as_ptr</span><span class=p>().</span><span class=n>add</span><span class=p>(</span><span class=n>old</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>non_const_mask</span><span class=p>)</span><span class=w> </span><span class=p>})</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span></code></pre></div><ul>
<li>自定义迭代器一定不要忘记实现 TrustedLen， 提高迭代器遍历生成Vec的性能:</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=k>unsafe</span><span class=w> </span><span class=k>impl</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=n>TrustedLen</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>PrimitiveViewer</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>Scalar</span><span class=o>&lt;</span><span class=n>Viewer</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>PrimitiveType</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>ScalarRef</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=p>,</span><span class=w> </span><span class=n>ScalarType</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>Scalar</span><span class=o>&lt;</span><span class=n>RefType</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=k>impl</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=nb>ExactSizeIterator</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>PrimitiveViewer</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=p>,</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=w>
</span><span class=w></span><span class=k>where</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>Scalar</span><span class=o>&lt;</span><span class=n>Viewer</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>PrimitiveType</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>ScalarRef</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=p>,</span><span class=w> </span><span class=n>ScalarType</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w>    </span><span class=n>T</span>: <span class=nc>Scalar</span><span class=o>&lt;</span><span class=n>RefType</span><span class=o>&lt;&#39;</span><span class=na>a</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>T</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span><span class=w></span><span class=p>{</span><span class=w>
</span><span class=w>    </span><span class=k>fn</span> <span class=nf>len</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>size</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pos</span><span class=w>
</span><span class=w>    </span><span class=p>}</span><span class=w>
</span><span class=w></span><span class=p>}</span><span class=w>
</span><span class=w>
</span></code></pre></div><p>最后来个viewer引用的示例, <a href=https://github.com/datafuselabs/databend/blob/fe84f5e40f4ac96306ef71618ade9171d865ea81/common/functions/src/scalars/strings/concat_ws.rs target=_blank rel="noopener noreffer">concat_ws 实现</a>：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=kd>let</span><span class=w> </span><span class=n>viewers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>columns</span><span class=w>
</span><span class=w>	</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w>
</span><span class=w>	</span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>column</span><span class=o>|</span><span class=w> </span><span class=n>Vu8</span>::<span class=n>try_create_viewer</span><span class=p>(</span><span class=n>column</span><span class=p>.</span><span class=n>column</span><span class=p>()))</span><span class=w>
</span><span class=w>	</span><span class=p>.</span><span class=n>collect</span>::<span class=o>&lt;</span><span class=nb>Result</span><span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;&gt;&gt;</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>builder</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>MutableStringColumn</span>::<span class=n>with_capacity</span><span class=p>(</span><span class=n>rows</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>buffer</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span>::<span class=n>with_capacity</span><span class=p>(</span><span class=mi>32</span><span class=p>);</span><span class=w>
</span><span class=w></span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=n>rows</span><span class=p>).</span><span class=n>for_each</span><span class=p>(</span><span class=o>|</span><span class=n>row</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=n>buffer</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span><span class=w>
</span><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>idx</span><span class=p>,</span><span class=w> </span><span class=n>viewer</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>viewers</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>enumerate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=o>!</span><span class=n>viewer</span><span class=p>.</span><span class=n>null_at</span><span class=p>(</span><span class=n>row</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=n>idx</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span><span class=w>		</span><span class=n>buffer</span><span class=p>.</span><span class=n>extend_from_slice</span><span class=p>(</span><span class=n>sep</span><span class=p>);</span><span class=w>
</span><span class=w>		</span><span class=p>}</span><span class=w>
</span><span class=w>
</span><span class=w>		</span><span class=n>buffer</span><span class=p>.</span><span class=n>extend_from_slice</span><span class=p>(</span><span class=n>viewer</span><span class=p>.</span><span class=n>value_at</span><span class=p>(</span><span class=n>row</span><span class=p>));</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=p>}</span><span class=w>
</span><span class=w>	</span><span class=n>builder</span><span class=p>.</span><span class=n>append_value</span><span class=p>(</span><span class=n>buffer</span><span class=p>.</span><span class=n>as_slice</span><span class=p>());</span><span class=w>
</span><span class=w></span><span class=p>});</span><span class=w>
</span><span class=w></span><span class=nb>Ok</span><span class=p>(</span><span class=n>builder</span><span class=p>.</span><span class=n>to_column</span><span class=p>())</span><span class=w>
</span></code></pre></div><h2 id=过程宏>过程宏</h2>
<p>Tikv中引入了一个非常复杂的过程宏来生产向量化函数表达式，在databend中有过类似的尝试，但由于过程宏的实现过于复杂，自定义函数虽然代码量稍多，但会比较灵活，可读性以及维护性都比较好，所以我们这里没有使用过程宏。</p>
<h2 id=总结>总结：</h2>
<p>经过type-exercise的改造后，聚合函数和标量函数的计算终于可以以非常精简的方式实现了，最后特别感谢迟先生的体操教程以及在这个过程中给出的建议，tql！！！</p>
</div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>更新于 2022-02-25</span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md></div>
<div class=post-info-share>
<span></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span>
</section>
</div>
<div class=post-nav><a href=/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86/ class=prev rel=prev title=2022年，我为什么又开始写博客了><i class="fas fa-angle-left fa-fw"></i>2022年，我为什么又开始写博客了</a></div>
</div>
<div id=comments><div id=gitalk class=comment></div><noscript>
Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk></a>Gitalk</a>.
</noscript></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line>
</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=http://github.com/sundy-li target=_blank>sundy-li</a></span></div>
</div>
</footer></div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部>
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论>
<i class="fas fa-comment fa-fw"></i>
</a>
</div><link rel=stylesheet href=/lib/gitalk/gitalk.min.e1f973627089fc121272c24d146e7c52e316a203fcb362eb2f648d803fc0d327.css integrity="sha256-4flzYnCJ/BIScsJNFG58UuMWogP8s2LrL2SNgD/A0yc="><script type=text/javascript src=/lib/gitalk/gitalk.min.3e68fce688cb68f396c11b65309c267b307f420f01cef269e5e4f3bd769801f0.js integrity="sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="></script><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.bcff85fb5e00d68802850b393ac7792c997f722f536f38e26638c46dca8e5eb6.js integrity="sha256-vP+F+14A1ogChQs5Osd5LJl/ci9TbzjiZjjEbcqOXrY="></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.615590a2ca2b667afa7c02ef396f5500b62e22795ddbb46448f90494605d09a5.js integrity="sha256-YVWQosorZnr6fALvOW9VALYuInld27RkSPkElGBdCaU="></script><script type=text/javascript src=/lib/lunr/lunr.min.df84a2d58ea594c04a3371b48d020b55ea10284c2ec636e4e331965d7313e29b.js integrity="sha256-34Si1Y6llMBKM3G0jQILVeoQKEwuxjbk4zGWXXMT4ps="></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.115461812ca5b093f9bcc2f15d2693a6c90e8fe38dabf2375e5f18e1c348d97c.js integrity="sha256-EVRhgSylsJP5vMLxXSaTpskOj+ONq/I3Xl8Y4cNI2Xw="></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.b3aab24bd69b746d28f433f4a82ecfa1556a75ba5ef9f4caa2bcc7ab8d327c14.js integrity="sha256-s6qyS9abdG0o9DP0qC7PoVVqdbpe+fTKorzHq40yfBQ="></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.fb649fcae62177dfe63e67081ddceb830b5ce1f05a4184e9bbb7d87ac4b8f4e5.js integrity="sha256-+2SfyuYhd9/mPmcIHdzrgwtc4fBaQYTpu7fYesS49OU="></script><script type=text/javascript src=/lib/clipboard/clipboard.min.8a7739925f4c03586479852df840b7061948832a7fda30c8c812d2ea4dd4c4f2.js integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI="></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:100},comment:{gitalk:{admin:["sundy-li"],clientID:"0bbabc78136bab58c4d5",clientSecret:"944414617574f7803ac3b687931e677c371901be",id:"2022-02-25T11:21:28+08:00",owner:"sundy-li",repo:"sundy-li.github.io",title:"类型体操在databend中的应用"}},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.f51938f3065a40ee841bcb558e4330e31fd26c0ea55343fff8770b88b0319a3c.js integrity="sha256-9Rk48wZaQO6EG8tVjkMw4x/SbA6lU0P/+HcLiLAxmjw="></script></body>
</html>