[{"categories":["Thinking"],"content":"知识沉淀 《如何高效学习》中提出过费曼学习法。费曼学习法也称“费曼定理”，很多人将其奉行为终极学习法。 费曼学习法整体来说可以简化为四个单词：Concept （概念）、Teach （教给别人）、Review （回顾）、Simplify （简化）。 前面第一步到第二步是一个被动学习转换为主动学习的过程，后面两步可以理解为复习消化的过程。 在《穷爸爸与富爸爸》 一书中，作者第一章节也提出了主动学习相比被动学习的好处： 写博客是需要花费不少精力的，学是一回事，写是一回事，教又是另外一回事。将自己学到新的知识或者体会到的新的思想观，经过自我消化整理后，用简练的文字和配图写成博文分享给大众。整个过程走下来，其实也走过了费曼学习法的四个环节。于人于己，我看到了撰写博文的好处，不仅仅传播了知识，也加深了自己掌握的知识沉淀。 ","date":"2022-01-02","objectID":"/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86/:1:0","tags":null,"title":"2022年，我为什么又开始写博客了","uri":"/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86/"},{"categories":["Thinking"],"content":"社区的交流讨论 个人在阅读上掌握的知识，在理解上可能带有个人的偏见，如果将学到的东西用偏见的思维积累下来，长期下来，可能会导致自己固步自封，对其他不一样的思想主观上有拒绝倾向。 将知识公开在博客，可以引起社区成员的关注，评论系统是一个非常好的交流方式，有利于纠正对事情不对的理解和偏见。 之前一直将一些技术杂七杂八地粘贴在个人的印象笔记中，现在觉得更多的东西应该沉淀到博客中反而更能引起大众的共鸣。 ","date":"2022-01-02","objectID":"/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86/:2:0","tags":null,"title":"2022年，我为什么又开始写博客了","uri":"/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86/"},{"categories":["Thinking"],"content":"从众心理 我非常佩服一些长期坚持写技术博客的博主，比如 阮一峰, 左耳朵耗子 等，还有我工作中的一些优秀的同事：drxp, xuanwo, codedump。在阅读他们的博客的时候，不仅仅可以看到他们对技术的思考，也有对生活的领悟。 现在我也有小孩了，假如我能将工作生活上的东西积累到博客中，孩子长大了或许能看到我的博客，也许能理解到当时的我在做什么，思考什么，虽然我那时候可能老了，但也算是一种时间上的慰藉吧，就像许飞的那首 父亲的散文诗. ","date":"2022-01-02","objectID":"/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86/:3:0","tags":null,"title":"2022年，我为什么又开始写博客了","uri":"/posts/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E4%BA%86/"},{"categories":["Code"],"content":" 本文将介绍一下c++代码模板的小技巧 —– CRTP ","date":"2021-01-28","objectID":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/:0:0","tags":["Template"],"title":"C++代码模板之CRTP","uri":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/"},{"categories":["Code"],"content":"虚函数 在介绍 CRTP 之前，我们先来了解下虚函数。 虚函数是通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数，从而实现了多态的特性。 一段简单的代码示例 class A { public: virtual void print() { std::cout \u003c\u003c \"Hello from A\" \u003c\u003c std::endl; } }; class B : public A { public: void print() override { std::cout \u003c\u003c \"Hello from B\" \u003c\u003c std::endl; } }; 虚函数实现了多态的特性，但是每次调用的时候都要对虚函数表进行 look-up, 所以开销不低，较之直接调用具体对象的方法，虚函数调用通常会慢一个数量级以上。在一些对性能敏感领域的软件系统中，比如OLAP数据库系统，需要对海量数据进行计算分析，虚函数的调用将会放大特别严重。 ","date":"2021-01-28","objectID":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/:1:0","tags":["Template"],"title":"C++代码模板之CRTP","uri":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/"},{"categories":["Code"],"content":"CRTP 奇异递归模板模式(Curiously Recurring Template Pattern，CRTP)，CRTP是C++模板编程时的一种常见技巧（idiom）：把派生类作为基类的模板参数。更一般地被称作F-bound polymorphism，是一类F 界量化。 ","date":"2021-01-28","objectID":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/:2:0","tags":["Template"],"title":"C++代码模板之CRTP","uri":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/"},{"categories":["Code"],"content":"CRTP 的基本范式 template \u003ctypename T\u003e class Base { ... }; class Derived : public Base\u003cDerived\u003e { ... }; 这样做的目的在于在基类中使用派生类的方法，从基类的角度来看，派生类也是一个基类，基类可以通过static_cast将其转为派生类，从而静态使用派生类的成员和方法，如下： template \u003ctypename T\u003e class Base { public: void doWhat() { T\u0026 derived = static_cast\u003cT\u0026\u003e(*this); // use derived... } }; ","date":"2021-01-28","objectID":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/:2:1","tags":["Template"],"title":"C++代码模板之CRTP","uri":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/"},{"categories":["Code"],"content":"静态动态 Andrei Alexandrescu在Modern C++ Design中称 CRTP 为静态多态（static polymorphism）。 相比于普通继承方式实现的多台，CRTP可以在编译器实现类型的绑定，这种方式实现了虚函数的效果，同时也避免了动态多态的代价。 ","date":"2021-01-28","objectID":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/:2:2","tags":["Template"],"title":"C++代码模板之CRTP","uri":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/"},{"categories":["Code"],"content":"权限控制 为了让基类能访问派生类的私有成员或方法，我们可以在派生类中和基类成为友元类。 friend class Base\u003cDerived\u003e; ","date":"2021-01-28","objectID":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/:2:3","tags":["Template"],"title":"C++代码模板之CRTP","uri":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/"},{"categories":["Code"],"content":"std::enable_shared_from_this 假如在c++中想要在一个已被shareptr管理的类型对象内获取并返回this，为了防止被管理的对象已被智能指针释放，而导致this成为悬空指针，可能会考虑以share_ptr的形式返回this指针，我们可以使用 std::enable_shared_from_this， 它本身就是一种CRTP在标准库中的实现 struct FOO: std::enable_shared_from_this\u003cFOO\u003e { std::shared_ptr\u003cFOO\u003e getptr() { return shared_from_this(); } }; ","date":"2021-01-28","objectID":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/:2:4","tags":["Template"],"title":"C++代码模板之CRTP","uri":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/"},{"categories":["Code"],"content":"CRTP 示例 (来自clickhouse源码) /// Implement method to obtain an address of 'add' function. template \u003ctypename Derived\u003e class IAggregateFunctionHelper : public IAggregateFunction { private: static void addFree(const IAggregateFunction * that, AggregateDataPtr place, const IColumn ** columns, size_t row_num, Arena * arena) { static_cast\u003cconst Derived \u0026\u003e(*that).add(place, columns, row_num, arena); } public: IAggregateFunctionHelper(const DataTypes \u0026 argument_types_, const Array \u0026 parameters_) : IAggregateFunction(argument_types_, parameters_) {} AddFunc getAddressOfAddFunction() const override { return \u0026addFree; } void addBatch(size_t batch_size, AggregateDataPtr * places, size_t place_offset, const IColumn ** columns, Arena * arena) const override { for (size_t i = 0; i \u003c batch_size; ++i) static_cast\u003cconst Derived *\u003e(this)-\u003eadd(places[i] + place_offset, columns, i, arena); } void addBatchSinglePlace(size_t batch_size, AggregateDataPtr place, const IColumn ** columns, Arena * arena) const override { for (size_t i = 0; i \u003c batch_size; ++i) static_cast\u003cconst Derived *\u003e(this)-\u003eadd(place, columns, i, arena); } void addBatchArray( size_t batch_size, AggregateDataPtr * places, size_t place_offset, const IColumn ** columns, const UInt64 * offsets, Arena * arena) const override { size_t current_offset = 0; for (size_t i = 0; i \u003c batch_size; ++i) { size_t next_offset = offsets[i]; for (size_t j = current_offset; j \u003c next_offset; ++j) static_cast\u003cconst Derived *\u003e(this)-\u003eadd(places[i] + place_offset, columns, j, arena); current_offset = next_offset; } } }; ","date":"2021-01-28","objectID":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/:2:5","tags":["Template"],"title":"C++代码模板之CRTP","uri":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/"},{"categories":["Code"],"content":"总结 如果想在编译期确定通过基类来得到派生类的行为，CRTP便是一种绝佳的选择， :) ","date":"2021-01-28","objectID":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/:3:0","tags":["Template"],"title":"C++代码模板之CRTP","uri":"/posts/c++%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF%E4%B9%8Bcrtp/"},{"categories":null,"content":"中年90后程序员，江西赣州人士，毕业于中山大学。 常用网名sundy-li, 曾就职于虎牙 \u0026 bigo，目前在datafuselabs 工作，专注研究实时云原生数仓，GitHub 远程工作中。 博客模板来自于Hugo 主题 LoveIt ","date":"2021-01-02","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["ClickHouse"],"content":"前言 如果要按工具链友好度评选一门最佳语言，我会首选 Golang，因为它有一系列的go tool工具，面向开发者非常友好。 其中go tool pprof 结合 go-torch ，能快速得出go程序的火焰图。在Linux系统中， perf 工具也十分强大，里面有各种子工具分析系统级进程的性能。perf 通常结合 FlameGraph 可以生成不错的火焰图。在一次偶然的机会中，笔者接触到了 SpeedScope，本文以调优 ClickHouse 为例子，介绍一下 SpeedScope 工具的使用。 ","date":"2020-09-11","objectID":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:1:0","tags":["profile","ClickHouse"],"title":"使用SpeedScope作性能分析","uri":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["ClickHouse"],"content":"SpeedScope 介绍 SpeedScope 是一款在线的 flamegraph 可视化工具。它可以和多个编程语言相结合，也可以将 perf report的结果拖拽到网站里面在线分析。 ","date":"2020-09-11","objectID":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:2:0","tags":["profile","ClickHouse"],"title":"使用SpeedScope作性能分析","uri":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["ClickHouse"],"content":"安装(可选) speedscope 是 nodejs 编写的，安装这个工具是可选的，安装后可以基于本地生成可视化性能图。 sudo npm install -g speedscope ","date":"2020-09-11","objectID":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:3:0","tags":["profile","ClickHouse"],"title":"使用SpeedScope作性能分析","uri":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["ClickHouse"],"content":"使用 我们在ClickHouse 里面执行一个”简单“且“复杂“的SQL的SQL，计算十亿个数的平均值。 selectavg(number)fromnumbers(1000000000);使用 perf 工具\"记录\"程序性能, 记录10s perf record -a -F 999 -g -p 17562 sleep 10 如果安装了 speedscope 工具， 我们可以直接在shell中调用 perf script -i perf.data | speedscope - 这个命令会生成一个静态html文件，本地的话可以直接打开进入可视化页面。但笔者并没有这样做，因为笔者在公司服务器作了perf记录，静态html其实是生成了一个到npm modules的跳转，无法拉到本地的浏览器打开。 不过没事，我们可以将生成script拉到本地后,拖拽到 https://www.speedscope.app/ 中打开。 perf script -i perf.data \u003e profile.linux-perf.txt 进入页面后，我们可以非常直观地看到各个时间轴上的调用开销时间占用情况。上面截图中，可以反映出，10s内的采样中，有5.99s 耗在 AggregateFunctionAvg 函数中， 有 2.14s 耗在 NumbersSource::generate 生成中。 使用 Perf 的方式，我们可以很直观得看到性能图，但我们并不能针对特定的SQL进行profile，下面介绍下 clickhouse-speedscope 如何针对特定SQL进行profile。 ","date":"2020-09-11","objectID":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:4:0","tags":["profile","ClickHouse"],"title":"使用SpeedScope作性能分析","uri":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["ClickHouse"],"content":"clickhouse-speedscope 第一次接触到SpeedScope，是无意中看到了 clickhouse-speedscope 项目。这个项目巧妙地利用了 clickhouse的系统表 system.trace_log 进行采样。 注意：要使用system.trace_log ，必须安装好 clickhouse-common-static-dbg 库, 并且开启 allow_introspection_functions等参数，更多配置参数参考这里. Clone clickhouse-speedscope 后，发现代码非常简单，核心就一个python文件，监控了http端口进行处理请求的返回。 pip安装好依赖库后，我们首先开启下端口监听 8089端口，同时会转发 query_id 查询 服务器域名为ck001 的clickhouse-server python main.py --ch-host ck001 --proxy-port 8089 然后，我们在 clickhouse 层执行SQL，这里为了方便快速获取 query-id ，我们打开logs输出，以及打开函数抽样trace的开关 ubuntu:)setsend_logs_level='trace';SETsend_logs_level='trace'Ok.0rowsinset.Elapsed:0.021sec.ubuntu:)setallow_introspection_functions=0;SETallow_introspection_functions=0[ubuntu]2020.09.1123:02:13.061146[17134]{d4a0c7af-c836-4360-8264-926f634e1d94}\u003cDebug\u003eexecuteQuery:(from127.0.0.1:52012)SETallow_introspection_functions=0[ubuntu]2020.09.1123:02:13.061471[17134]{d4a0c7af-c836-4360-8264-926f634e1d94}\u003cDebug\u003eMemoryTracker:Peakmemoryusage(forquery):0.00B.Ok.0rowsinset.Elapsed:0.042sec. 这里我们就可以看到具体日志了，然后我们继续执行那个”简单“且“复杂“的SQL （线上40core 128G服务器） ubuntu:)selectavg(number)fromnumbers(1000000000);SELECTavg(number)FROMnumbers(1000000000)[ubuntu]2020.09.1123:03:58.739452[17134]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cDebug\u003eexecuteQuery:(from127.0.0.1:52012)SELECTavg(number)FROMnumbers(1000000000)→Progress:0.00rows,0.00B(0.00rows/s.,0.00B/s.)[ubuntu]2020.09.1123:03:58.739624[17134]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cTrace\u003eAccessRightsContext(default):Accessgranted:numbers()ON*.*[ubuntu]2020.09.1123:03:58.739649[17134]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cTrace\u003eAccessRightsContext(default):Accessgranted:numbers()ON*.*[ubuntu]2020.09.1123:03:58.747053[17134]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cTrace\u003eInterpreterSelectQuery:FetchColumns-\u003eComplete[ubuntu]2020.09.1123:03:58.747139[17134]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cDebug\u003eexecuteQuery:Querypipeline:ExpressionExpressionAggregatingConcatExpressionTreeExecutor↘Progress:75.96millionrows,607.65MB(699.98millionrows/s.,5.60GB/s.)7%[ubuntu]2020.09.1123:03:58.747262[28335]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cTrace\u003eAggregator:Aggregating[ubuntu]2020.09.1123:03:58.747377[28335]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cTrace\u003eAggregator:Aggregationmethod:without_key┌─avg(number)─┐│499999999.5│└─────────────┘↖Progress:951.06millionrows,7.61GB(746.09millionrows/s.,5.97GB/s.)█████████████████████████████████████████████████████▎94%[ubuntu]2020.09.1123:04:00.013119[28335]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cTrace\u003eAggregator:Aggregated.1000000000to1rows(from7629.395MiB)in1.266sec.(790016853.437rows/sec.,6027.350MiB/sec.)[ubuntu]2020.09.1123:04:00.013271[28335]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cTrace\u003eAggregator:Mergingaggregateddata[ubuntu]2020.09.1123:04:00.013537[17134]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cInformation\u003eexecuteQuery:Read1000013824rows,7.45GiBin1.274sec.,784921953rows/sec.,5.85GiB/sec.[ubuntu]2020.09.1123:04:00.013576[17134]{6e4b5384-39c5-4d02-9383-e312e92f2681}\u003cDebug\u003eMemoryTracker:Peakmemoryusage(forquery):137.09KiB.1rowsinset.Elapsed:1.275sec.Processed1.00billionrows,8.00GB(784.34millionrows/s.,6.27GB/s.) 拿到了query-id，之后，我们通过 curl 可以直接获取到traceing的结果。 curl 'http://localhost:8089/query?query_id=fe9078cd-9570-4895-b328-4728a097306a' | speedscope - 如果没有装 speedscope， 也可以重定向到一个文件中，然后拖拽到 https://www.speedscope.app/ 中。 ","date":"2020-09-11","objectID":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:5:0","tags":["profile","ClickHouse"],"title":"使用SpeedScope作性能分析","uri":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["ClickHouse"],"content":"总结 使用 speedscope， 我们在本地就可以很方便地对 ClickHouse 进行远程 profile，去试试吧！ ","date":"2020-09-11","objectID":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:6:0","tags":["profile","ClickHouse"],"title":"使用SpeedScope作性能分析","uri":"/posts/%E4%BD%BF%E7%94%A8speedscope%E4%BD%9C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"}]